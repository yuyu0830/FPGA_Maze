40*30*2

플레이어, 클리어 칸은 따로 빼서 2bit->1bit로 줄이자 (40*30*1=1200)

빈칸:검정
벽:하얗
플레이어:빨강
클리어:초록

플레이어 포지션(x,y) -> 들어온 maze 값에서 포지션에 맞으면 정해진 색 넣기



vsync hsync는 드로잉 모듈에서 연산하고
vpos hpos은 Top에서 연산하도록 뺀다

sync만 해가지고 현재 픽셀 포인트 띄워준다

1. 연산을 Top으로 뺐다
2. 키보드 모듈 완성 +키보드 작동 사진
3. 모니터 모듈 구색 갖춤
4. 코드 화면 보여주면서 미완상태임 알림
5. 2차원 배열 만들어서 해보려 하고있다



기본틀은 그대로(연산을 Ingame, Drawing으로 나누려했는데, 그 ingame 연산이 모든 하위모듈에서 필요하게 됨[ex. MazeState]. 그래서 관련 값을 Top으로 빼서 확장. 무슨 픽셀 색상값을 그리는지도 Top에서 할것.

그래서 드로잉모듈은 Sync 맞추는 역할만 한다 -> vPos, hPos 출력

Top은 Pos를 받아서 토대로 어디위치에 있는지 계산
- 미로레벨마다 블럭당 차지하는 픽셀크기 계산
(예시. vPos, hPos를 블럭당 차지하는 픽셀수로 나눠서 몇번째 블럭인지 확인)
Maze State에서 체크결과에 나눠서 색 반환
벽이 아니면 플레이어 포지션? 레드, 골지점이면? 초록, 아니면? 빈칸이므로 검정

Level 업을 하면 레벨별 블럭이 차지하는 픽셀크기 값을 입력받아



<>
1. 키보드 입력 -> fModule : 눌렸다라는 1비트신호 -> fOPush로 무슨 값이 눌렸는지 확인 -> 움직일 수 있는 입력인지 확인 (못 움직이면 다시 Idle)(갈수있으면 플레이어 이동후 골지점에 간 건지 확인 [골지점과 같으면 레벨 업 로직][다르면 포지션만 옮기고 그려내기])
2. 드로잉 모듈에서 Vsync Hsync 모두 처음으로 돌아올때 flag(fDraw_Done) 아웃풋

KB_o_Direction 받으면 Top모듈에서 유효한지 확인








/.//////////////////////

12.14 발표 평가

코드는 발표에서 보여주는 거 아님. 불친절함.
기능,구조도, FSM, KB FSM, Sync FSM, 최종결과(코드)는 맨뒤에 둘것
개발현황 슬라이드에서 키보드 설명만 쏙 빼서 설명해주자
키보드 모듈은 버튼 4개이므로 모듈이 4개인 거임. KB1, ..., KB4
clk, rst은 기본적인것이므로 표시x

vga 코드에 대해서 :
clk은 들어온 거 그대로 나간다

1. vga controller 필요가 필요. 640*480, 800*525
미로 크기는 640*480보다는 작으니까,
1)미로크기를 640에 맞춰 확대하는 방법 : 불필요하게 큰 640*480레지스터가 필요해짐

40*30이 바뀌었을때 640*480로 바꿔주는 컨트롤러가 필요. Sync+Draw 합쳐서, 40*30을 640*480로 바꿔서 픽셀단위로 뿌려주기.
Sync, vPos, hPos는 필요없고, MazeMap[40*30=1200비트]을 그대로 Draw 안에 집어넣어서 다룰 것
Draw 존재 자체는 논리적인 것. 코드짜는건 DotMatrix 참조하자

Draw 안에서 xy좌표 나오고, 그 좌표에 대해 rgb 넣어주기 vs 맵 통째로 Draw에 집어넣고 rgb 넣어 뿌려주기 = 후자가 더 편하다.

구체화가 덜된상태.

VGA처럼 강의에서 안배운 건 프레젠테이션에서 VGA 모듈 보여주기 전에 설명 넣어주기



vga 참고 : https://vanhunteradams.com/DE1/VGA_Driver/Driver.html

하드웨어 레지스터(n_Push 등) 설명에도 설명 넣어주세요
verilog for문은 코드 길이 줄여주는거밖에 도움이 안됨. 하드웨어는 반복실행&반복구현의 개념이 없기 때문.